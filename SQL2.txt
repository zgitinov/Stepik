/*
2. Связь «один ко многим»
Рассмотрим таблицу book(в ней столбец author переименован в name_author):

book_id		title					name_author			price	amount
1			Мастер и Маргарита		Булгаков М.А.		670.99	3
2			Белая гвардия			Булгаков М.А.		540.50	5
3			Идиот					Достоевский Ф.М.	460.00	10
4			Братья Карамазовы		Достоевский Ф.М.	799.01	2
5			Стихотворения и поэмы	Есенин С.А.			650.00	15

В этой таблице фамилии авторов повторяются для нескольких книг. 
А что, если придется вместо инициалов для каждого автора хранить его полное имя и отчество? 
Тогда, если в таблице содержится информация о 50 книгах Достоевского, придется 50 раз исправлять «Ф.М.» на «Федор Михайлович». 
При этом, если в некоторых записях использовать «Фёдор Михайлович» (c буквой ё), то мы вообще получим двух разных авторов... 

Чтобы устранить эту проблему в реляционных базах данных создается новая таблица author, 
в которой перечисляются все различные авторы, а затем эта таблица связывается с таблицей book. 
При этом такая связь называется «один ко многим», таблица author называется главной, таблица book – связанной или подчиненной. 

Связь «один ко многим» имеет место, когда одной записи главной таблицы соответствует несколько записей связанной таблицы, 
а каждой записи связанной таблицы соответствует только одна запись главной таблицы. Обозначается это так:

Этапы реализации связи «один ко многим» на следующем примере:

Один автор может написать несколько книг, а одна книга написана только одним автором. 
Для каждой книги известны ее количество и цена.
1. Создать таблицу author,  в которую включить уникальных авторов книг, хранящихся на складе
2. Обе таблицы должны содержать первичный ключ, в таблице  bookон уже есть,  в таблицу authorдобавим ключ author_id
3. Включить в таблицу book связанный столбец (внешний ключ, FOREIGN KEY), 
соответствующий по имени и типу ключевому столбцу главной таблицы (в нашем случае это столбец author_id). 
Для наглядности связь на схеме обозначается стрелкой от ключевого столбца главной таблицы к внешнему ключу связной таблицы

2.1 Связь «многие ко многим»
На предыдущем шаге мы реализовали связь «один ко многим» для книг и авторов. 
Она означает, что каждый автор написал несколько книг, но каждую книгу написал только один автор. 
На самом деле, это не совсем верное утверждение. Например, книга «12 стульев» написана двумя авторами Ильфом И.А. и Петровым Е.П. 
С другой стороны, эти авторы написали и другие книги, например «Золотой теленок».

Для соединения таких таблиц используется связь «многие ко многим».

Связь «многие ко многим» имеет место когда каждой записи одной таблицы соответствует несколько записей во второй, 
и наоборот, каждой записи второй таблицы соответствует несколько записей в первой

Этапы реализации связи «многие ко многим»  на следующем примере:

Один автор может написать несколько книг, а одна книга может быть написана несколькими авторами. 
Для каждой книги известны ее количество и цена.
1. Создать таблицу author,  в которую включить уникальных авторов книг, хранящихся на складе
2. В обеих таблицах необходимо определить первичный ключ, в нашем случае в таблице book он уже есть, 
поэтому достаточно включить первичный ключ author_id в таблицу author
3. Создать новую таблицу-связку, состоящую из двух столбцов, соответствующих по имени и типу ключевым столбцам исходных таблиц. 
Каждый из этих столбцов является внешним ключом (FOREIGN KEY)  и связан с ключевым столбцом каждой таблицы. 
Для наглядности связи на схеме обозначаются стрелкой от ключевого столбца исходной таблицы к внешнему ключу связной таблицы
4. Дальше необходимо определиться с первичным ключом таблицы-связки. 
Можно сделать два ключевых столбца, тогда все записи в этой таблице должны быть уникальными, то есть не повторяться. 
Для связи автор-книга этот вариант подходит. Но в некоторых случаях записи в таблице-связке могут повторяться, 
например, если мы будем продавать книги покупателям (один человек может купить несколько книг, 
а одну и ту же книгу могут купить несколько человек). Тогда в таблицу-связку включают дополнительные столбцы для идентификации записей, 
например, дату продажи,  также в таблицу-связку добавляют первичный ключ. 
Мы воспользуемся вторым способом
*/
/*
2.2 Запросы на выборку, соединение таблиц

Соединение INNER JOIN
Оператор внутреннего соединения INNER JOIN соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является 
симметричным.
*/
SELECT
 ...
FROM
    таблица_1 INNER JOIN  таблица_2
    ON условие
...
/*
Результат запроса формируется так:

каждая строка одной таблицы сопоставляется с каждой строкой второй таблицы;
для полученной «соединённой» строки проверяется условие соединения;
если условие истинно, в таблицу результата добавляется соответствующая «соединённая» строка;
Пример

Вывести название книг и их авторов.

Запрос:
*/
SELECT title, name_author
FROM 
    author INNER JOIN book
    ON author.author_id = book.author_id;
/*	
Поскольку поля author_id в таблицах book и author называются одинаково, необходимо в запросах указывать полную ссылку на них 
(book.author_id и author.author_id).

Результат:

+-----------------------+------------------+
| title                 | name_author      |
+-----------------------+------------------+
| Мастер и Маргарита    | Булгаков М.А.    |
| Белая гвардия         | Булгаков М.А.    |
| Идиот                 | Достоевский Ф.М. |
| Братья Карамазовы     | Достоевский Ф.М. |
| Игрок                 | Достоевский Ф.М. |
| Стихотворения и поэмы | Есенин С.А.      |
| Черный человек        | Есенин С.А.      |
| Лирика                | Пастернак Б.Л.   |
+-----------------------+------------------+
В данном запросе осуществляется соединение главной таблицы author и зависимой таблицы book по ключевому столбцу author.author_id и 
внешнему ключу book.author_id. При этом в результирующую таблицу запроса включаются все строки, в которых значения этих столбцов совпадают. 
Другими словами строки зависимой таблицы book дополняются фамилией и инициалами авторов из таблицы author.

Задание
Вывести название, жанр и цену тех книг, количество которых больше 8, в отсортированном по убыванию цены виде.
*/

SELECT 
	title, name_genre, price
FROM
    genre INNER JOIN book
    ON genre.genre_id = book.genre_id
WHERE 
	book.amount >= 8
ORDER BY 
	price DESC;

/*
Внешнее соединение LEFT и RIGHT OUTER JOIN
Оператор внешнего соединения LEFT OUTER JOIN  (можно использовать LEFT JOIN) соединяет две таблицы. Порядок таблиц для оператора важен, 
поскольку оператор не является симметричным.
*/
SELECT
 ...
FROM
    таблица_1 LEFT JOIN  таблица_2
    ON условие
...
/*
Результат запроса формируется так:

в результат включается внутреннее соединение (INNER JOIN) первой и второй таблицы в соответствии с условием;
затем в результат добавляются те записи первой таблицы, которые не вошли во внутреннее соединение на шаге 1, 
для таких записей соответствующие поля второй таблицы заполняются значениями NULL.
Соединение RIGHT JOIN действует аналогично, только в пункте 2 первая таблица меняется на вторую и наоборот.

Пример

Вывести название всех книг каждого автора, если книг некоторых авторов в данный момент нет на складе – вместо названия книги указать Null.

Запрос:
*/
SELECT name_author, title 
FROM author LEFT JOIN book
     ON author.author_id = book.author_id
ORDER BY name_author;   
/*  
Результат:

+------------------+-----------------------+
| name_author      | title                 |
+------------------+-----------------------+
| Булгаков М.А.    | Мастер и Маргарита    |
| Булгаков М.А.    | Белая гвардия         |
| Достоевский Ф.М. | Игрок                 |
| Достоевский Ф.М. | Идиот                 |
| Достоевский Ф.М. | Братья Карамазовы     |
| Есенин С.А.      | Стихотворения и поэмы |
| Есенин С.А.      | Черный человек        |
| Лермонтов М.Ю.   | NULL                  |
| Пастернак Б.Л.   | Лирика                |
+------------------+-----------------------+
Так как в таблице book нет книг Лермонтова, напротив этой фамилии стоит Null.

Задание
Вывести все жанры, которые не представлены в книгах на складе.
*/

SELECT 
    genre.name_genre, book.title
FROM 
    genre LEFT JOIN book
    ON genre.genre_id = book.genre_id
WHERE 
    title IS NULL;
	
/*
Перекрестное соединение CROSS JOIN
Оператор перекрёстного соединения, или декартова произведения CROSS JOIN 
(в запросе вместо ключевых слов можно поставить запятую между таблицами) соединяет две таблицы. 
Порядок таблиц для оператора неважен, поскольку оператор является симметричным. Его структура:

SELECT
 ...
FROM
    таблица_1 CROSS JOIN  таблица_2
...
или

SELECT
 ...
FROM
    таблица_1, таблица_2
...
Результат запроса формируется так: каждая строка одной таблицы соединяется с каждой строкой другой таблицы, формируя  в результате 
все возможные сочетания строк двух таблиц.

Например, запрос:

SELECT name_author, name_genre
FROM 
    author, genre;
каждому автору из таблицы author поставит в соответствие все возможные жанры из таблицы genre:

+------------------+-------------+
| name_author      | name_genre  |
+------------------+-------------+
| Булгаков М.А.    | Роман       |
| Булгаков М.А.    | Поэзия      |
| Булгаков М.А.    | Приключения |
| Достоевский Ф.М. | Роман       |
| Достоевский Ф.М. | Поэзия      |
| Достоевский Ф.М. | Приключения |
| Есенин С.А.      | Роман       |
| Есенин С.А.      | Поэзия      |
| Есенин С.А.      | Приключения |
| Пастернак Б.Л.   | Роман       |
| Пастернак Б.Л.   | Поэзия      |
| Пастернак Б.Л.   | Приключения |
| Лермонтов М.Ю.   | Роман       |
| Лермонтов М.Ю.   | Поэзия      |
| Лермонтов М.Ю.   | Приключения |
+------------------+-------------+

Задание
Есть список городов, хранящийся в таблице city:

city_id	name_city
1		Москва
2		Санкт-Петербург
3		Владивосток

Необходимо в каждом городе провести выставку книг каждого автора в течение 2020 года. 
Дату проведения выставки выбрать случайным образом. Создать запрос, который выведет город, автора и дату проведения выставки. 
Последний столбец назвать Дата. Информацию вывести, отсортировав сначала в алфавитном порядке по названиям городов, 
а потом по убыванию дат проведения выставок.

Пояснение
1. Для генерации случайной даты можно к первому числу года ('2020-01-01') прибавить целое случайное число в интервале от 0 до 365.

Генерации случайных чисел в интервале от 0 до 1 (не включительно) осуществляется с помощью функции RAND(). 
Если эту функцию умножить на 365, то она будет генерировать вещественные числа от 0 до 365 (не включительно). 
Осталось только отбросить дробную часть. Это можно сделать с помощью функции FLOOR(), которая возвращает наибольшее целое число, 
меньшее или равное указанному числовому значению. Таким образом, случайное число от 0 до 365 можно получить с помощью выражения:

FLOOR(RAND() * 365)
Важно! Даты должны быть за 2020 год, первое число года - 1 января 2020 года.

2. Для сложения  даты с числом используется функция:

DATE_ADD(дата, INTERVAL число единица_измерения),

где
  единица_измерения (использовать прописные буквы) – это день (DAY), месяц(MONTH), неделя(WEEK) и пр., 
  число – целое число,
  дата – значение даты или даты и времени.
Функция к дате  прибавляет указанное число, выраженное в днях, месяцах и пр. , в зависимости от заданного интервала, 
и возвращает новую дату.

Например:

DATE_ADD('2020-02-02', INTERVAL 45 DAY) возвращает 18 марта 2020 года
DATE_ADD('2020-02-02', INTERVAL 6 MONTH) возвращает 2 августа 2020 года
*/

SELECT
    name_city,
    name_author,
    DATE_ADD('2020-01-01', INTERVAL FLOOR(RAND()*365) DAY) AS Дата
FROM 
	city CROSS JOIN author
ORDER BY
    name_city,
    Дата DESC;
	
/*